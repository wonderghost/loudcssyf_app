/**
 * Vuikit 0.8.10
 * (c) 2018 Miljan Aleksic
 * @license MIT
**/

/* Substantial part of the code is adapted from UIkit,
  Copyright (c) 2013-2018 YOOtheme GmbH, getuikit.com */

import { isFunction, isObject } from './lang';

var win = typeof window !== 'undefined' && window;
var Promise = win && 'Promise' in window ? window.Promise : PromiseFn;
var Deferred = function Deferred () {
  var this$1 = this;
  this.promise = new Promise(function (resolve, reject) {
    this$1.reject = reject;
    this$1.resolve = resolve;
  });
};
var RESOLVED = 0;
var REJECTED = 1;
var PENDING = 2;
var async = win && 'setImmediate' in window ? setImmediate : setTimeout;
function PromiseFn (executor) {
  this.state = PENDING;
  this.value = undefined;
  this.deferred = [];
  var promise = this;
  try {
    executor(
      function (x) {
        promise.resolve(x);
      },
      function (r) {
        promise.reject(r);
      }
    );
  } catch (e) {
    promise.reject(e);
  }
}
PromiseFn.reject = function (r) {
  return new PromiseFn(function (resolve, reject) {
    reject(r);
  })
};
PromiseFn.resolve = function (x) {
  return new PromiseFn(function (resolve, reject) {
    resolve(x);
  })
};
PromiseFn.all = function all (iterable) {
  return new PromiseFn(function (resolve, reject) {
    var result = [];
    var count = 0;
    if (iterable.length === 0) {
      resolve(result);
    }
    function resolver (i) {
      return function (x) {
        result[i] = x;
        count += 1;
        if (count === iterable.length) {
          resolve(result);
        }
      }
    }
    for (var i = 0; i < iterable.length; i += 1) {
      PromiseFn.resolve(iterable[i]).then(resolver(i), reject);
    }
  })
};
PromiseFn.race = function race (iterable) {
  return new PromiseFn(function (resolve, reject) {
    for (var i = 0; i < iterable.length; i += 1) {
      PromiseFn.resolve(iterable[i]).then(resolve, reject);
    }
  })
};
var p = PromiseFn.prototype;
p.resolve = function resolve (x) {
  var promise = this;
  if (promise.state === PENDING) {
    if (x === promise) {
      throw new TypeError('Promise settled with itself.')
    }
    var called = false;
    try {
      var then = x && x.then;
      if (x !== null && isObject(x) && isFunction(then)) {
        then.call(
          x,
          function (x) {
            if (!called) {
              promise.resolve(x);
            }
            called = true;
          },
          function (r) {
            if (!called) {
              promise.reject(r);
            }
            called = true;
          }
        );
        return
      }
    } catch (e) {
      if (!called) {
        promise.reject(e);
      }
      return
    }
    promise.state = RESOLVED;
    promise.value = x;
    promise.notify();
  }
};
p.reject = function reject (reason) {
  var promise = this;
  if (promise.state === PENDING) {
    if (reason === promise) {
      throw new TypeError('Promise settled with itself.')
    }
    promise.state = REJECTED;
    promise.value = reason;
    promise.notify();
  }
};
p.notify = function notify () {
  var this$1 = this;
  async(function () {
    if (this$1.state !== PENDING) {
      while (this$1.deferred.length) {
        var ref = this$1.deferred.shift();
        var onResolved = ref[0];
        var onRejected = ref[1];
        var resolve = ref[2];
        var reject = ref[3];
        try {
          if (this$1.state === RESOLVED) {
            if (isFunction(onResolved)) {
              resolve(onResolved.call(undefined, this$1.value));
            } else {
              resolve(this$1.value);
            }
          } else if (this$1.state === REJECTED) {
            if (isFunction(onRejected)) {
              resolve(onRejected.call(undefined, this$1.value));
            } else {
              reject(this$1.value);
            }
          }
        } catch (e) {
          reject(e);
        }
      }
    }
  });
};
p.then = function then (onResolved, onRejected) {
  var this$1 = this;
  return new PromiseFn(function (resolve, reject) {
    this$1.deferred.push([onResolved, onRejected, resolve, reject]);
    this$1.notify();
  })
};
p.catch = function (onRejected) {
  return this.then(undefined, onRejected)
};

export { win, Promise, Deferred };
