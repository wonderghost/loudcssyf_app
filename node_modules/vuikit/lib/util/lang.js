/**
 * Vuikit 0.8.10
 * (c) 2018 Miljan Aleksic
 * @license MIT
**/

/* Substantial part of the code is adapted from UIkit,
  Copyright (c) 2013-2018 YOOtheme GmbH, getuikit.com */

function bind (fn, context) {
  return function (a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(context, arguments) : fn.call(context, a) : fn.call(context)
  }
}
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}
var hyphenateRe = /([a-z\d])([A-Z])/g;
function hyphenate (str) {
  return str
    .replace(hyphenateRe, '$1-$2')
    .toLowerCase()
}
var camelizeRE = /-(\w)/g;
function camelize (str) {
  return str.replace(camelizeRE, toUpper)
}
function toUpper (_, c) {
  return c ? c.toUpperCase() : ''
}
function ucfirst (str) {
  return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : ''
}
var strPrototype = String.prototype;
var startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0 };
function startsWith (str, search) {
  return startsWithFn.call(str, search)
}
var endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search };
function endsWith (str, search) {
  return endsWithFn.call(str, search)
}
var includesFn = function (search) { return ~this.indexOf(search) };
var includesStr = strPrototype.includes || includesFn;
var includesArray = Array.prototype.includes || includesFn;
function includes (obj, search) {
  return obj && (isString(obj) ? includesStr : includesArray).call(obj, search)
}
var isArray = Array.isArray;
function isFunction (obj) {
  return typeof obj === 'function'
}
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}
function isPlainObject (obj) {
  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype
}
function isWindow (obj) {
  return isObject(obj) && obj === obj.window
}
function isDocument (obj) {
  return isObject(obj) && obj.nodeType === 9
}
function isJQuery (obj) {
  return isObject(obj) && !!obj.jquery
}
function isNode (element) {
  return typeof Node !== 'undefined' && element instanceof Node || isObject(element) && element.nodeType === 1
}
function isNodeCollection (element) {
  return typeof NodeList !== 'undefined' && element instanceof NodeList ||
    typeof HTMLCollection !== 'undefined' && element instanceof HTMLCollection
}
function isBoolean (value) {
  return typeof value === 'boolean'
}
function isString (value) {
  return typeof value === 'string'
}
function isNumber (value) {
  return typeof value === 'number'
}
function isNumeric (value) {
  return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value))
}
function isUndefined (value) {
  return value === void 0
}
function toBoolean (value) {
  return isBoolean(value)
    ? value
    : value === 'true' || value === '1' || value === ''
      ? true
      : value === 'false' || value === '0'
        ? false
        : value
}
function toNumber (value) {
  var number = Number(value);
  return !isNaN(number) ? number : false
}
function toFloat (value) {
  return parseFloat(value) || 0
}
function toNode (element) {
  return isNode(element) || isWindow(element) || isDocument(element)
    ? element
    : isNodeCollection(element) || isJQuery(element)
      ? element[0]
      : isArray(element)
        ? toNode(element[0])
        : null
}
var arrayProto = Array.prototype;
function toNodes (element) {
  return isNode(element)
    ? [element]
    : isNodeCollection(element)
      ? arrayProto.slice.call(element)
      : isArray(element)
        ? element.map(toNode).filter(Boolean)
        : isJQuery(element)
          ? element.toArray()
          : []
}
function toList (value) {
  return isArray(value)
    ? value
    : isString(value)
      ? value.split(/,(?![^(]*\))/).map(function (value) { return isNumeric(value)
        ? toNumber(value)
        : toBoolean(value.trim()); })
      : [value]
}
function toMs (time) {
  return !time
    ? 0
    : endsWith(time, 'ms')
      ? toFloat(time)
      : toFloat(time) * 1000
}
function swap (value, a, b) {
  return value.replace(new RegExp((a + "|" + b), 'mg'), function (match) {
    return match === a ? b : a
  })
}
var assign = Object.assign || function (target) {
  var args = [], len = arguments.length - 1;
  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
  target = Object(target);
  for (var i = 0; i < args.length; i++) {
    var source = args[i];
    if (source !== null) {
      for (var key in source) {
        if (hasOwn(source, key)) {
          target[key] = source[key];
        }
      }
    }
  }
  return target
};
function each (obj, cb) {
  for (var key in obj) {
    if (cb.call(obj[key], obj[key], key) === false) {
      break
    }
  }
}
function sortBy (collection, prop) {
  return collection.sort(function (a, b) { return a[prop] - b[prop]; })
}
function clamp (number, min, max) {
  if ( min === void 0 ) min = 0;
  if ( max === void 0 ) max = 1;
  return Math.min(Math.max(number, min), max)
}
function noop () {}
function intersectRect (r1, r2) {
  return r1.left <= r2.right &&
        r2.left <= r1.right &&
        r1.top <= r2.bottom &&
        r2.top <= r1.bottom
}
function pointInRect (point, rect) {
  return intersectRect({top: point.y, bottom: point.y, left: point.x, right: point.x}, rect)
}
var Dimensions = {
  ratio: function ratio (dimensions, prop, value) {
    var obj;
    var aProp = prop === 'width' ? 'height' : 'width';
    return ( obj = {}, obj[aProp] = Math.round(value * dimensions[aProp] / dimensions[prop]), obj[prop] = value, obj)
  },
  contain: function contain (dimensions, maxDimensions) {
    var this$1 = this;
    dimensions = assign({}, dimensions);
    each(dimensions, function (_, prop) { return dimensions = dimensions[prop] > maxDimensions[prop]
      ? this$1.ratio(dimensions, prop, maxDimensions[prop])
      : dimensions; }
    );
    return dimensions
  },
  cover: function cover (dimensions, maxDimensions) {
    var this$1 = this;
    dimensions = this.contain(dimensions, maxDimensions);
    each(dimensions, function (_, prop) { return dimensions = dimensions[prop] < maxDimensions[prop]
      ? this$1.ratio(dimensions, prop, maxDimensions[prop])
      : dimensions; }
    );
    return dimensions
  }
};

export { bind, hasOwn, hyphenate, camelize, ucfirst, startsWith, endsWith, includes, isArray, isFunction, isObject, isPlainObject, isWindow, isDocument, isJQuery, isNode, isNodeCollection, isBoolean, isString, isNumber, isNumeric, isUndefined, toBoolean, toNumber, toFloat, toNode, toNodes, toList, toMs, swap, assign, each, sortBy, clamp, noop, intersectRect, pointInRect, Dimensions };
