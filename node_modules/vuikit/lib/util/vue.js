/**
 * Vuikit 0.8.10
 * (c) 2018 Miljan Aleksic
 * @license MIT
**/

/* Substantial part of the code is adapted from UIkit,
  Copyright (c) 2013-2018 YOOtheme GmbH, getuikit.com */

import { get } from './misc';
import { assign } from './lang';

function findParent (instance) {
  return findParents(instance).pop()
}
function findParents (instance) {
  var parents = [];
  var name = instance.$options.name;
  var parent = instance.$parent;
  while (parent) {
    if (parent.$options.name === name) {
      parents.unshift(parent);
    }
    parent = parent.$parent;
  }
  return parents
}
function findChilds (instance) {
  var name = instance.$options.name;
  var childs = instance.$children
    .filter(function (child) { return child.$options.name === name; });
  childs.forEach(function (child) {
    childs = childs.concat( findChilds(child));
  });
  return childs
}
function resolveSlots (children) {
  return filterOutTextNodes(children).reduce(function (slots, n) {
    var name = get(n, 'data.slot', 'default');
    slots[name] = slots[name] || [];
    if (n.tag === 'template') {
      slots[name].push.apply(slots[name], n.children || []);
    } else {
      slots[name].push(n);
    }
    return slots
  }, {})
}
function apply (instance, fn) {
  if (!instance || !instance._isVue) {
    return
  }
  fn(instance);
  instance.$children.forEach(function (child) { return apply(child, fn); });
}
function filterOutTextNodes (nodes) {
  return nodes.filter(function (n) { return n.tag || isAsyncPlaceholder(n); })
}
function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}
function extractProps () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];
  var props = {};
  for (var i = 0; i < args.length; i++) {
    var def = args[i];
    if (def !== null) {
      def.mixins && def.mixins.forEach(function (mixin) {
        assign(props, mixin.props || {});
      });
      def.extends && assign(props, extractProps(def.extends));
      def.props && assign(props, def.props);
    }
  }
  return props
}
function mergeData () {
  var arguments$1 = arguments;
  for(var e,a,s={},t=arguments.length;t--;){ for(var r=0,c=Object.keys(arguments[t]);r<c.length;r++){ switch(e=c[r]){case"class":case"style":case"directives":Array.isArray(s[e])||(s[e]=[]), s[e]=s[e].concat(arguments$1[t][e]);break;case"staticClass":if(!arguments$1[t][e]){ break; }void 0===s[e]&&(s[e]=""), s[e]&&(s[e]+=" "), s[e]+=arguments$1[t][e].trim();break;case"on":case"nativeOn":s[e]||(s[e]={});for(var o=0,n=Object.keys(arguments[t][e]);o<n.length;o++){ a=n[o], s[e][a]?s[e][a]=[].concat(s[e][a],arguments$1[t][e][a]):s[e][a]=arguments$1[t][e][a]; }break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":s[e]||(s[e]={}), s[e]=__assign({},arguments$1[t][e],s[e]);break;case"slot":case"key":case"ref":case"tag":case"show":case"keepAlive":default:s[e]||(s[e]=arguments$1[t][e]);} } }return s}var __assign=Object.assign||function(e){
  var arguments$1 = arguments;
for(var a,s=1,t=arguments.length;s<t;s++){a=arguments$1[s];for(var r in a){ Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r]); }}return e
};

export { findParent, findParents, findChilds, resolveSlots, apply, filterOutTextNodes, isAsyncPlaceholder, extractProps, mergeData };
