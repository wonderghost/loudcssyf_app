/**
 * Vuikit 0.8.10
 * (c) 2018 Miljan Aleksic
 * @license MIT
**/

/* Substantial part of the code is adapted from UIkit,
  Copyright (c) 2013-2018 YOOtheme GmbH, getuikit.com */

import { on } from './event';
import { clamp, isNumeric, isString, isUndefined, toNode, toNodes, toNumber } from './lang';

var doc = typeof document !== 'undefined' && document;
function isReady () {
  return doc && (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll)
}
function ready (fn) {
  if (!doc) {
    return
  }
  if (isReady()) {
    fn();
    return
  }
  var handle = function () {
    unbind1();
    unbind2();
    fn();
  };
  var unbind1 = on(document, 'DOMContentLoaded', handle);
  var unbind2 = on(window, 'load', handle);
}
function index (element, ref) {
  return ref
    ? toNodes(element).indexOf(toNode(ref))
    : toNodes((element = toNode(element)) && element.parentNode.children).indexOf(element)
}
function getIndex (i, elements, current, finite) {
  if ( current === void 0 ) current = 0;
  if ( finite === void 0 ) finite = false;
  elements = toNodes(elements);
  var length = elements.length;
  i = isNumeric(i)
    ? toNumber(i)
    : i === 'next'
      ? current + 1
      : i === 'previous'
        ? current - 1
        : index(elements, i);
  if (finite) {
    return clamp(i, 0, length - 1)
  }
  i %= length;
  return i < 0 ? i + length : i
}
function empty (element) {
  element = toNode(element);
  element.innerHTML = '';
  return element
}
function html (parent, html) {
  parent = toNode(parent);
  return isUndefined(html)
    ? parent.innerHTML
    : append(parent.hasChildNodes() ? empty(parent) : parent, html)
}
function prepend (parent, element) {
  parent = toNode(parent);
  if (!parent.hasChildNodes()) {
    return append(parent, element)
  } else {
    return insertNodes(element, function (element) { return parent.insertBefore(element, parent.firstChild); })
  }
}
function append (parent, element) {
  parent = toNode(parent);
  return insertNodes(element, function (element) { return parent.appendChild(element); })
}
function before (ref, element) {
  ref = toNode(ref);
  return insertNodes(element, function (element) { return ref.parentNode.insertBefore(element, ref); })
}
function after (ref, element) {
  ref = toNode(ref);
  return insertNodes(element, function (element) { return ref.nextSibling
    ? before(ref.nextSibling, element)
    : append(ref.parentNode, element); }
  )
}
function insertNodes (element, fn) {
  element = isString(element) ? fragment(element) : element;
  return element
    ? 'length' in element
      ? toNodes(element).map(fn)
      : fn(element)
    : null
}
function remove (element) {
  toNodes(element).map(function (element) { return element.parentNode && element.parentNode.removeChild(element); });
}
function wrapAll (element, structure) {
  structure = toNode(before(element, structure));
  while (structure.firstChild) {
    structure = structure.firstChild;
  }
  append(structure, element);
  return structure
}
function wrapInner (element, structure) {
  return toNodes(toNodes(element).map(function (element) { return element.hasChildNodes ? wrapAll(toNodes(element.childNodes), structure) : append(element, structure); }
  ))
}
function unwrap (element) {
  toNodes(element)
    .map(function (element) { return element.parentNode; })
    .filter(function (value, index, self) { return self.indexOf(value) === index; })
    .forEach(function (parent) {
      before(parent, parent.childNodes);
      remove(parent);
    });
}
var fragmentRE = /^\s*<(\w+|!)[^>]*>/;
var singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;
function fragment (html) {
  var matches = singleTagRE.exec(html);
  if (matches) {
    return document.createElement(matches[1])
  }
  var container = document.createElement('div');
  if (fragmentRE.test(html)) {
    container.insertAdjacentHTML('beforeend', html.trim());
  } else {
    container.textContent = html;
  }
  return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild
}
function apply (node, fn) {
  if (!node || node.nodeType !== 1) {
    return
  }
  fn(node);
  node = node.firstElementChild;
  while (node) {
    apply(node, fn);
    node = node.nextElementSibling;
  }
}

export { isReady, ready, index, getIndex, empty, html, prepend, append, before, after, remove, wrapAll, wrapInner, unwrap, fragment, apply };
